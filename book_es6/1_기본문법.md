# let 키워드
ES6 블록 스코프 변수를 선언하는 키워드로 선언과 동시에 값을 할당할 수 있다.

## 함수 스코프 변수 선언
var 키워드로 선언한 변수를 함수 스코프 변수(function scoped variable)라고 하며,
함수 밖에 선언한 함수 스코프 변수는 전역 범위로,
함수 안에 선언하면 함수 밖을 제외한 내부 어디서건 접근이 가능하다.
```js
var a = 12
function myFunction() {
    console.log(a);
    var b = 13;
    if(true) {
        var c = 14;
        console.log(b);
    }
    console.log(c);
}
myFunction();
// 12
// 13
// 14
```
if문 밖에서도 변수 c는 접근 가능하지만, 다른 언어에서는 불가능 하다.

### 블록 스코프 변수 선언
let 키워드로 선언한 변수를 블록 스코프 변수라고 하며, 함수 밖에 선언하면 함수 스코프 변수처럼 천역 접근할 수 있다.
블록 안에 선언하면 정의한 블록(또는 하위 블록)에서만 접근 가능하며 블록 밖에서는 불 수 없다.
```js
let a = 12;
function myFunction() {
    console.log(a);
    let b = 13;
    if(true) {
        let c = 14;
        console.log(b);
    }
    console.log(c);
}
myFunction();
// 12
// 13
// VM1203:9 Uncaught ReferenceError: c is not defined(…)
```

## 변수 재선언
이미 var로 선언한 변수를 다시 var로 선언하면 덮어쓴다.
```js
var a = 0;
var a = 1;
console.log(a);

function myFunction() {
    var b = 2;
    var b = 3;
    console.log(b);
}
myFunction();
// 1
// 3

// let 키워드 사용
let a = 0;
let a = 1; //Uncaught SyntaxError: Identifier 'a' has already been declared

function myFunction() {
    var b = 2;
    var b = 3;
    if(true) {
        let c = 14;
        let c = 4;
    }
}
//ncaught SyntaxError: Identifier 'c' has already been declared
myFunction();
```

# const 키워드
ES6 const 키워드는 일기 전용 변수, 값을 다시 할당할 수 없는 상수를 선언한다.

 es5 이전
```js
var const_pi = 3.141;
var r = 2;
console.log(const_pi * r * r); //12.564
```
pi값은 상수 지만, 프로그램에서 변숫값을 고칠 수 없게 막을수 없다.

es6
```js
const pi = 3.141;
const r = 2;
console.log(pi * r * r); //12.564

pi = 12 ; // Uncaught TypeError: Assignment to constant variable.(…)
```
pi값을 바꾸려고 하면 오류가 발생한다.

### 상수의 스코프
상수는 블록 스코프 변수라 let으로 선언한 변수와 스코프 규칙은 같다.

### 상수를 통한 객체 참조

# 파라미터 기본값

# 펼침 연산자

## 펼침 연사자의 다른 용례

### 배열 값을 다른 배열의 일부로 만듦

### 배열 값을 다른 배열에 밀어 넣기

### 여러 배열 펼침

# 나머지 파라미터

# 해체 할당
해체 할당(destructuring assignment)은 이터러블이나 객체의 값/프로퍼티를 각각 배열이나 객체 생성자 리터럴과 비슷한 구문으로 변수에 할당하는 표현식
'배열 해체 할당' 과 '객체 해체 할당' 두 가지 유형이 있다.

## 배열 해체 할당.
이터러블 객체에서 값을 추출하여 변수에 할당한다.

```js
// es5 이전
var myArray = [1, 2, 3];
var a = myArray[0];
var b = myArray[1];
var c = myArray[2];

//es6
let myArray = [1, 2, 3];
[a, b, c] = myArray; // 배열 해체 할당 구문

//or
[a, b, c] = [1, 2, 3]
```

### 값을 건너뛴다.
```js
let [a, , b] = [1, 2, 3];
console.log(a); //1
console.log(b); //3
```

### 배열 해체 할당에 나머지 연산자를 사용
```js
let [a, ...b] =  [1, 2, 3, 4, 5, 6];
console.log(a); // 1
console.log(Array.isArray(b)); // true
console.log(b); // [2, 3, 4, 5, 6];
```

### 변수의 기본값
```js
let [a, b, c=3] = [1, 2];
console.log(c); // 3
```

### 중첩 배열 해체
```js
let [a, b, [c, d]] = [1, 2, [3, 4]];
```

### 파라미터로 배열 해체 할당 사용
해체 할당 표현식을 함수 파라미터 자리에 넣으면 함수에 넘긴 이터러블 객체 값을 추출할 수 있다.
```js
function myFunction([a, b, c = 3]) {
    console.log(a, b, c); // 실행 결과 1 2 3
}
myFunction([1, 2]);
```

## 객체 해체 할당
객체 프로퍼티 값을 추출해서 변수에 할당한다.

```js
// es5 이전
var object = {"name" : "민호", "age" : 23};
var name = object.name;
var age = object.age;

// es6
let object = {"name" : "민호", "age" : 23};
let name, age;
({name, age} = object);
```

### 변수의 기본값
객체 프로퍼티가 undefined일 경우에는 변수에 기본값을 준다.
```js
let {a, b, c = 3} = {a : '1', b : '2'};
console.log(c);
```

### 조합 프로퍼티명을 해체
프로퍼티명을 동적으로 조합할 경우 표현식을 []로 감싼다.
```js
let {["first" + "Name"] : x} = { firstName : "수지" };
console.log(x); // 수지
```

### 중첩 객체를 해체
중첩된 객체, 즉 객체 속 객체의 프로퍼티는 다음과 같이 추출한다.
```js
var {name, otherInfo : {age}} = {name:"수지", otherInfo : {age : 23}};
console.log(name, age);
```

### 파라미터로 객체 해체 할당 사용
배열 해체 할당과 더불어 객체 해체 할당도 함수 파라미터로 사용 가능하다.
```js
function myFunction({name = "수지", age = 23, profession = "연예인"} = {} ) {
    console.log(name, age, profession);
}
myFunction({name:"민호",age:25});
```
