
### 정적 메소드
클래스 바디에서 메소드명 앞에 static을 붙인 메소드를 정적 메소드(static method)라 한다.  
**클래스 prototype 프로퍼티가 아닌, 클래스의 자체 메소드** 이다.  
예를들어 String.fromCharCode() 메소드는 String 생성자의 정적 메소드, 즉 String 함수 자신의 고유 프로퍼티다.  
정적 메소드는 주로 어플리케이션의 유틸리티 함수 작성에 쓰인다.
```js
class Student
{
    constructor(name) {
        this.name = name;
    }

    findName(student) {
        return student.name;
    }
}

var s = new Student("수지");
var name = Student.findName(s);
console.log(name); // 수지

// 함수 버전
function Student(name)
{
    this.name = name;
}

Student.findName = function(student) {
    return student.name;
}

var s = new Student("수지");
var name = Student.findName(s);

console.log(name); // 수지
```

### 클래스 상속 구현
ES6부터 클래스에 **extends** 절 및 **super** 키워드를 도입하였다.  
extends 절로 클래스가 다른 생성자의 정적/비정적 프로퍼티를 상속할 수 있게 하였다.

super 키워드 용도
- 클래스 constructor 메소드에서 부모 생성자를 호출한다.
- 클래스 메소드 내부에서 부모 생성자의 정적/비정적 메소드를 참조한다.

extends, super 키워드로 생성자 안에서 상속 계층 구현 예제.

```js
function A(a) {
    this.a = a;
}
A.prototype.printA = function() {
    console.log(this.a);
}

class B extends A
{
    constructor(a, b) {
        super(a);
        this.b = b;
    }

    printB() {
        console.log(this.b);
    }

    // prototype 영역이 아닌 함수 자신에게 추가됨.
    static sayHello() {
        console.log('안녕하세요.')
    }
}

class C extends B
{
    constructor(a, b, c) {
        super(a, b);
        this.c = c;
    }
    printC() {
        console.log(this.c);
    }

    printAll() {
        this.printC();
        this.printB();
        this.printA();
    }
}

var obj = new C(1, 2, 3);
obj.printAll(); // 3 2 1

C.sayHello();
// 안녕하세요.
//
obj.sayHello();
// Error obj.sayHello is not a function
// 프로토 탑입에 등록되어 있지 않기 때문에 체인으로 찾을 수 없음.
```

ES5 방식으로 변경... 생각 같이 잘 안되네;;;
```js
function A(a) {
    this.a = a;
}
A.prototype.printA = function() {
    console.log(this.a);
}

function B(a, b) {
    this.a = a;
    this.b = b;
}

B.sayHello = function() {
    console.log('안녕하세요.');
}

B.prototype = new A(B.a);

B.prototype.printB = function() {
    console.log(this.b);
}

function C(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;
};

C.sayHello = B.sayHello;

C.prototype = new B(C.a, C.b);

C.prototype.printC = function() {
    console.log(this.c);
}

C.prototype.printAll = function() {
    this.printC();
    this.printB();
    this.printA();
}

var obj = new C(1, 2, 3);
obj.printAll(); // 3 2 1

C.sayHello();
// 안녕하세요.
//
obj.sayHello();




function A(a) {
    this.a = a;
}
A.prototype.printA = function () {
    console.log(this.a);
};

var B = function (_A) {

    B.prototype = Object.create(_A && _A.prototype, {
         constructor: { value: B, enumerable: false, writable: true, configurable: true }
    });
    Object.setPrototypeOf ? Object.setPrototypeOf(B, _A) : B.__proto__ = _A;

    function B(a, b) {
        var _this = _A.call(this, a) && (typeof _A.call(this, a) === "object" || typeof _A.call(this, a) === "function") ? _A.call(this, a) : this;

        _this.b = b;
        return _this;
    }

    B.prototype.printB = function printB() {
        console.log(this.b);
    };

    B.sayHello = function sayHello() {
        console.log('안녕하세요.');
    };

    return B;
}(A);

var C = function (_B) {

    C.prototype = Object.create(_B && _B.prototype, {
         constructor: { value: C, enumerable: false, writable: true, configurable: true }
    });
    Object.setPrototypeOf ? Object.setPrototypeOf(C, _B) : C.__proto__ = _B;

    function C(a, b, c) {

        var _this2 = _B.call(this, a, b) && (typeof _B.call(this, a, b) === "object" || typeof _B.call(this, a, b) === "function") ? _B.call(this, a, b) : this;

        _this2.c = c;
        return _this2;
    }

    C.prototype.printC = function printC() {
        console.log(this.c);
    };

    C.prototype.printAll = function printAll() {
        this.printC();
        this.printB();
        this.printA();
    };

    return C;
}(B);

```
